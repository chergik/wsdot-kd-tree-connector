{
  "name": "look-alike",
  "version": "1.0.1",
  "description": "A simple-yet-powerful KD-tree library for NodeJS, with support for lightning-fast k-Nearest Neighbour queries. Supports normalization, weights, key and filter parameters",
  "main": "lib/kdtree.js",
  "scripts": {
    "test": "./node_modules/.bin/mocha --compilers coffee:coffee-script --reporter spec",
    "prepublish": "./node_modules/.bin/coffee --compile --output lib coffee"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/axiomzen/Look-Alike"
  },
  "keywords": [
    "knn",
    "kd-tree",
    "tree",
    "kdtree",
    "Machine",
    "Learning",
    "Recommender",
    "Systems",
    "Nearest",
    "Neighbor",
    "recommendation",
    "similarity"
  ],
  "author": {
    "name": "mck-",
    "email": "kuomarc2@gmail.com"
  },
  "license": "LGPL",
  "devDependencies": {
    "coffee-script": "~1.6.3",
    "mocha": "~1.12.0",
    "chai": "~1.7.2"
  },
  "dependencies": {
    "heap": "~0.2.1"
  },
  "homepage": "https://github.com/axiomzen/Look-Alike",
  "bugs": {
    "url": "https://github.com/axiomzen/Look-Alike/issues"
  },
  "readme": "Look-Alike\n===========\n[![Build Status](https://travis-ci.org/axiomzen/Look-Alike.png?branch=master)](https://travis-ci.org/axiomzen/Look-Alike)\n\nTwin brother of [Alike](https://github.com/axiomzen/Alike). They look quite alike. Except this brother is more heavy-weight and likes playing in trees.\n\nA simple-yet-powerful KD-tree library for NodeJS, with support for lightning-fast k-Nearest Neighbour queries. Supports normalization, weights, key and filter parameters.\n\n## Look-Alike vs Alike\n\nBut if Look-Alike is more powerful than Alike, why use Alike at all? Well, [TANSTAAFL](http://en.wikipedia.org/wiki/There_ain't_no_such_thing_as_a_free_lunch)\n\nAlike is more nimble and functional and does not require state. You can call it with thousands of rows and it will still be fast (`n log n`). It is also better when the rows change often (no need to rebuild the tree).\n\nLook-Alike builds the tree in advance (which is the only way to beat `n log n`) and holds it in memory. It supports kNN queries that can be as fast as `k log n`, so is the prefered brother when you have more than a few thousand rows. The tree does not change -- it would need to be rebuild (at `n log2 n`) before the query when the rows change.\n\n## Quickstart\n\nTo install and add it to your `package.json`\n\n```\n$ npm install look-alike --save\n```\n\nNow you can load up the module and use it like so:\n\n```javascript\nLA = require('look-alike');\ntree = new LA([rows]);\ntop3 = tree.query(subject, {k:3});\n```\n\nGiven `[rows]` is an array of gazillion objects with `x` numerical attributes, `top3` now holds an array of the 3 closest objects to `subject`. The second-easiest Recommender System you will ever see (aside from [Alike](https://github.com/axiomzen/Alike)).\n\n## Overview\n\nLook-Alike exports a single class with a constructor and a single instance method.\n\nThe constructor expects an array of objects, and optionally an object of options:\n\n  - `objects[Array]` - The rows from which we build our tree\n  - `options[Object] (optional)` - which may include:\n    - `attributes[Array] (optional)` - An array of strings which list attributes/dimensions to use in the KD-tree. By default, will use all keys of the first object in `objects`. Specifying which keys to use for the tree is useful if you want to include additional information in the objects (such as an id, or a label, or more).\n    - `key[Function] (optional)` - A `key` function, which is used to map over `objects` to get to the `attributes`. Useful when the attributes are nested in the parent object.\n\n\nThe instance method is called `query` and expects the following parameters:\n\n  - `subject[Object]` - The reference point that we want to find the Nearest Neighbors of\n  - `options[Object] (optional)` - which may include:\n    - `k[Int] (default = 1)` - The number of objects to return. The query complexity is `k log n`, so the higher this number, the longer the algorithm takes (on average).\n    - `normalize[Bool] (default = true)` - When true, will normalize the attributes when calculating distances (recommended if attributes are not on the same scale). Note: turn off for small number of rows to avoid unexpected results! In those cases you should be using [Alike](https://github.com/axiomzen/Alike) anyway!\n    - `weights[Object] (optional)` - Define weights per attribute (e.g. `{x:0.3, y:0.7}` would weight attribute `y` at 70% and `x` at 30%. Defaults to equal weights)\n    - `filter[Function] (optional)` - When provided, only consider objects in the tree that pass the filter function (i.e. return true)\n\nAnd returns an array of objects in sorted order. You may look at the test-cases if you don't believe me.\n\n\n## Development\n\nLook-Alike is written in Literate CoffeeScript in the `coffee/` folder. Browse around on Github for the best annotated source experience!\n\nUnit tests are in the `test/` folder. You can run the tests with `npm test` or if you are developing, you may use `make watch-test` to watch while you TDD. :)\n\n## License\n\nLook-Alike is licensed under the terms of the [GNU Lesser General Public License](http://www.gnu.org/licenses/lgpl.html), known as the LGPL.",
  "readmeFilename": "README.md",
  "_id": "look-alike@1.0.1",
  "dist": {
    "shasum": "3fbdb440dbe16ff140bc74b83bb6dd2003393802",
    "tarball": "http://registry.npmjs.org/look-alike/-/look-alike-1.0.1.tgz"
  },
  "_from": "look-alike@*",
  "_npmVersion": "1.3.8",
  "_npmUser": {
    "name": "mck-",
    "email": "kuomarc2@gmail.com"
  },
  "maintainers": [
    {
      "name": "mck-",
      "email": "kuomarc2@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "3fbdb440dbe16ff140bc74b83bb6dd2003393802",
  "_resolved": "https://registry.npmjs.org/look-alike/-/look-alike-1.0.1.tgz"
}
